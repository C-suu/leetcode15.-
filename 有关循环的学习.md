```python
class Solution:
    def threeSum(self, nums):
        nums.sort()                         # 把数组从小到大排序
        res = []                            # 用来存放最终结果的列表

        n = len(nums)                       # 数组长度

        for i in range(n):                  # 固定第一个数的下标 i
            if i > 0 and nums[i] == nums[i - 1]:
                continue                    # 如果和前一个数一样，跳过，防止重复

            left = i + 1                    # 左指针，指向 i 右边的第一个数
            right = n - 1                   # 右指针，指向数组最后一个数

            while left < right:             # 左右指针没有相遇时循环
                total = nums[i] + nums[left] + nums[right]  # 三个数的和

                if total == 0:
                    res.append([nums[i], nums[left], nums[right]])  # 找到一个答案

                    left += 1               # 左指针右移
                    right -= 1              # 右指针左移

                    while left < right and nums[left] == nums[left - 1]:
                        left += 1           # 跳过重复的左边数字

                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1          # 跳过重复的右边数字

                elif total < 0:
                    left += 1               # 和太小，左指针右移

                else:
                    right -= 1              # 和太大，右指针左移

        return res                           # 返回所有不重复的三元组
```

# 对于上述代码的循环，不是很理解。for和if以及while是如何循环的？这里面有很多循环嵌套，一个也不理解。要像给计算机小白讲解一样，一个一个帮拆分讲解明白。同时，给出一个具体算例帮理解这里面这么多循环的嵌套。注意，算例要给出完整的示例表格不要省略每一次循环！

下面**只做一件事**：
把这段代码里的 **for / if / while 是如何一层一层“转起来的”** 彻底拆开，**像给完全不懂循环的初学者讲**，并且**用一个完整算例，把每一次循环发生了什么全部列成表格**，**不省略任何一次循环**。

---

# 一、先建立一个“总地图”：到底有几层循环？

先只看结构，不看代码细节。

```text
for 循环（最外层，大循环）
└── if 判断（过滤重复）
└── while 循环（中层，小循环）
    ├── if / elif / else（三选一判断）
    ├── while（跳过重复的 left）
    └── while（跳过重复的 right）
```

用一句话概括：

> **for 控制“第一个数换不换”，
> while 控制“另外两个数怎么找”，
> if 只负责“要不要、往哪走”。**

---

# 二、最外层：`for i in range(n)` 在干什么？

## 1️⃣ for 循环的本质（零基础版）

`for i in range(n)` 的意思是：

> **让 i 从 0 开始，一个一个加 1，直到 n-1，每个值都执行一次下面的代码。**

如果 `n = 6`，那么：

```text
第 1 次：i = 0
第 2 次：i = 1
第 3 次：i = 2
第 4 次：i = 3
第 5 次：i = 4
第 6 次：i = 5
```

---

## 2️⃣ 在这道题里，for 的职责是什么？

在这道题中：

> **for 循环负责“轮流固定第一个数字”。**

也就是说：

| for 的第几轮 | i 的值 | 固定的数字   |
| -------- | ---- | ------- |
| 第 1 轮    | 0    | nums[0] |
| 第 2 轮    | 1    | nums[1] |
| 第 3 轮    | 2    | nums[2] |
| ……       | ……   | ……      |

---

# 三、`if i > 0 and nums[i] == nums[i-1]` 是不是循环？

不是。

这是一个**闸门**。

## 它只做一件事：

> **如果当前固定的数字，和上一次固定的数字一样，就整轮 for 直接跳过。**

作用：

* 防止重复答案
* 不影响循环次数
* 只是决定“这一轮干不干活”

---

# 四、中层循环：`while left < right` 是真正“找答案”的地方

## 1️⃣ while 的本质（和 for 的区别）

* `for`：次数一开始就定好了
* `while`：**只要条件成立，就一直重复**

`while left < right` 的意思是：

> **只要左指针还在右指针左边，就不停地试。**

---

## 2️⃣ left 和 right 是谁？

* `left`：从左往右走
* `right`：从右往左走

二者一起：

> **像两只手从两边往中间夹**

---

# 五、最里层：`if / elif / else` 在干什么？

在 while 里面，每一轮都会算一次：

```text
total = nums[i] + nums[left] + nums[right]
```

然后只做三选一：

| 情况         | 含义  | 动作        |
| ---------- | --- | --------- |
| total == 0 | 刚刚好 | 记录答案，左右都动 |
| total < 0  | 太小  | left 向右   |
| total > 0  | 太大  | right 向左  |

**永远只会走其中一个分支。**

---

# 六、完整算例（不省略任何一次循环）

## 示例数组

```text
nums = [-1, 0, 1, 2, -1, -4]
```

排序后：

```text
[-4, -1, -1, 0, 1, 2]
```

长度：

```text
n = 6
```

---

## 第一层 for：i = 0（固定 -4）

| for轮次 | i | 固定值 |
| ----- | - | --- |
| 1     | 0 | -4  |

初始化：

```text
left = 1
right = 5
```

### while 循环全过程

| while轮次 | left   | right   | 三数      | total | 动作                 |
| ------- | ------ | ------- | ------- | ----- | ------------------ |
| 1       | 1(-1)  | 5(2)    | -4,-1,2 | -3    | total < 0 → left++ |
| 2       | 2(-1)  | 5(2)    | -4,-1,2 | -3    | left++             |
| 3       | 3(0)   | 5(2)    | -4,0,2  | -2    | left++             |
| 4       | 4(1)   | 5(2)    | -4,1,2  | -1    | left++             |
| 结束      | left=5 | right=5 | ——      | ——    | left ≥ right，结束    |

无结果。

---

## 第二层 for：i = 1（固定 -1）

| for轮次 | i | 固定值 |
| ----- | - | --- |
| 2     | 1 | -1  |

初始化：

```text
left = 2
right = 5
```

### while 循环全过程

| while轮次 | left   | right   | 三数      | total | 动作                |
| ------- | ------ | ------- | ------- | ----- | ----------------- |
| 1       | 2(-1)  | 5(2)    | -1,-1,2 | 0     | 记录，left++，right-- |
| 2       | 3(0)   | 4(1)    | -1,0,1  | 0     | 记录，left++，right-- |
| 结束      | left=4 | right=3 | ——      | ——    | left ≥ right      |

得到两个答案。

---

## 第三层 for：i = 2（固定 -1）

判断：

```text
nums[2] == nums[1]
```

成立 → **continue**

整轮 for 被跳过，**while 根本不会执行**。

---

## 第四层 for：i = 3（固定 0）

| for轮次 | i | 固定值 |
| ----- | - | --- |
| 4     | 3 | 0   |

初始化：

```text
left = 4
right = 5
```

### while 循环

| while轮次 | left   | right   | 三数    | total | 动作                  |
| ------- | ------ | ------- | ----- | ----- | ------------------- |
| 1       | 4(1)   | 5(2)    | 0,1,2 | 3     | total > 0 → right-- |
| 结束      | left=4 | right=4 | ——    | ——    | 结束                  |

---

## 第五层 for：i = 4

left = 5，right = 5
`left < right` 不成立 → while 不进

---

## 第六层 for：i = 5

left = 6，right = 5
`left < right` 不成立 → while 不进

---

# 七、用一句话彻底理解嵌套关系

> **for 决定“第一个数是谁”，
> while 决定“剩下两个数怎么找”，
> if 决定“这一轮往哪走”。**

所有循环并不是一起乱跑，而是**一层跑完，才进入下一层**。

---

如果需要，下一步可以继续做以下任意一种：

* 把某一次 while 的“指针移动”画成动画式解释
* 把 for / while 用“人排队”的现实类比讲解
* 单独只讲 `continue` 和 `break` 的区别
