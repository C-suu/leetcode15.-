# leetcode15. 三数之和 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]] `满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。注意：答案中不可以包含重复的三元组。

---

## （0）【纯人话，不写代码】解题思路（零基础版）

这道题的目标只有一句话：

> **从一堆整数里，找出所有三个数，它们加起来等于 0，而且不能重复。**

### 一、为什么不能用“瞎试”

假设数组里有 1000 个数。
如果随便选 3 个数来试：

* 第一个数有 1000 种选法
* 第二个数有 999 种
* 第三个数有 998 种

组合数量会非常非常多，计算机会“累死”。

所以需要**聪明的方法**。

---

### 二、关键思想：**排序 + 两头夹**

#### 第一步：排序

先把数组按从小到大排好，例如：

```
[-4, -1, -1, 0, 1, 2]
```

排序的好处：

* 小的在左边
* 大的在右边
* 数字有规律，方便“试探大小”

---

#### 第二步：固定一个数，再找另外两个数

思路是：

1. **先固定一个数**（当作“老大”）
2. 剩下的问题就变成：

> 在后面的数里，找两个数，让
> `这两个数 + 老大 = 0`

也就是：

```
这两个数的和 = -老大
```

---

#### 第三步：左右指针夹逼

在排好序的数组中：

* 左指针从小的一侧开始
* 右指针从大的一侧开始

然后：

* 如果三数之和 **太小** → 左指针往右走（变大）
* 如果三数之和 **太大** → 右指针往左走（变小）
* 如果刚好等于 0 → 记录答案，然后左右一起移动

---

#### 第四步：去重（非常重要）

题目明确说：

> **不能有重复的三元组**

所以：

* 固定的数如果和上一次一样，直接跳过
* 找到答案后，左右指针如果指向的数和刚才一样，也要跳过

---

### 五个字总结思路

> **排序 + 固定 + 夹逼 + 去重**

---

## （1）Python3 标准答案（每一行都有中文注释）

```python
class Solution:
    def threeSum(self, nums):
        nums.sort()                         # 把数组从小到大排序
        res = []                            # 用来存放最终结果的列表

        n = len(nums)                       # 数组长度

        for i in range(n):                  # 固定第一个数的下标 i
            if i > 0 and nums[i] == nums[i - 1]:
                continue                    # 如果和前一个数一样，跳过，防止重复

            left = i + 1                    # 左指针，指向 i 右边的第一个数
            right = n - 1                   # 右指针，指向数组最后一个数

            while left < right:             # 左右指针没有相遇时循环
                total = nums[i] + nums[left] + nums[right]  # 三个数的和

                if total == 0:
                    res.append([nums[i], nums[left], nums[right]])  # 找到一个答案

                    left += 1               # 左指针右移
                    right -= 1              # 右指针左移

                    while left < right and nums[left] == nums[left - 1]:
                        left += 1           # 跳过重复的左边数字

                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1          # 跳过重复的右边数字

                elif total < 0:
                    left += 1               # 和太小，左指针右移

                else:
                    right -= 1              # 和太大，右指针左移

        return res                           # 返回所有不重复的三元组
```

---

## （2）【一个字母一个字母、一句一句】解释代码（极端零基础）

下面从**最基本**开始解释。

---

### `class Solution:`

* `class`：定义一个“盒子”
* `Solution`：盒子的名字
* 这个盒子里专门放解题方法

---

### `def threeSum(self, nums):`

* `def`：定义一个功能
* `threeSum`：功能名字
* `nums`：传进来的数字列表，例如 `[-1,0,1]`

---

### `nums.sort()`

* `nums`：原始数字列表
* `.`：表示“对它做事情”
* `sort()`：排序
* 作用：把数字按从小到大排列

---

### `res = []`

* `=`：把右边的东西放进左边
* `[]`：空盒子（列表）
* `res`：用来装答案的盒子

---

### `n = len(nums)`

* `len`：长度
* `len(nums)`：nums 里有多少个数字
* `n`：记住这个数量

---

### `for i in range(n):`

* `for`：重复做事情
* `i`：下标，从 0 开始
* `range(n)`：0 到 n-1

---

### `if i > 0 and nums[i] == nums[i - 1]:`

* `i > 0`：不是第一个数
* `nums[i] == nums[i - 1]`：当前数字和前一个一样
* 意思：**这个数已经用过了**

---

### `continue`

* 跳过本次循环
* 直接去下一个 `i`

---

### `left = i + 1`

* 左指针
* 指向固定数字右边的第一个位置

---

### `right = n - 1`

* 右指针
* 指向数组最右边

---

### `while left < right:`

* 只要左边还在右边左侧
* 就继续找

---

### `total = nums[i] + nums[left] + nums[right]`

* 把三个数加起来
* 存到 `total`

---

### `if total == 0:`

* 如果刚好等于 0
* 找到一个答案

---

### `res.append([...])`

* `append`：把东西放进盒子
* 把三个数字一起放进去

---

### `left += 1` / `right -= 1`

* 左指针右移
* 右指针左移

---

### 跳过重复数字的 `while`

* 如果新指向的数字和刚才一样
* 继续移动
* 防止结果重复

---

### `elif total < 0`

* 和太小
* 需要更大的数
* 左指针右移

---

### `else`

* 和太大
* 需要更小的数
* 右指针左移

---

### `return res`

* 把结果交出去
* 算法结束

---

## （3）具体数值算例 + 过程表格

### 示例输入

```
nums = [-1, 0, 1, 2, -1, -4]
```

### 排序后

```
[-4, -1, -1, 0, 1, 2]
```

---

### 关键过程表（只列核心步骤）

| i位置 | 固定值 | left  | right | 三数之和 | 动作 |
| --- | --- | ----- | ----- | ---- | -- |
| 0   | -4  | 1(-1) | 5(2)  | -3   | 左移 |
| 0   | -4  | 2(-1) | 5(2)  | -3   | 左移 |
| 0   | -4  | 3(0)  | 5(2)  | -2   | 左移 |
| 0   | -4  | 4(1)  | 5(2)  | -1   | 左移 |
| 1   | -1  | 2(-1) | 5(2)  | 0    | 记录 |
| 1   | -1  | 3(0)  | 4(1)  | 0    | 记录 |

---

### 最终结果

```
[[-1, -1, 2], [-1, 0, 1]]
```

---

## （4）公式与关键表达式来源说明

### ① `三数之和 = nums[i] + nums[left] + nums[right]`

来源：
题目要求三个数加起来等于 0。

---

### ② `left < right`

来源：
三个数必须是**不同位置**，左右指针相遇就不能再组成三个数。

---

### ③ `nums[i] == nums[i - 1]`

来源：
排序后，相同的数会挨在一起。
如果继续使用，会产生**重复答案**。

---


# `nums.sort()`根据这个说清楚sort 与 sorted 区别。sorted() 函数对所有可迭代的对象进行排序操作。Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。

下面**只围绕 `nums.sort()`** 这一句，把 **`sort`、`sorted`、以及顺带提到的 `join`** 讲清楚，**从概念 → 行为 → 区别 → 为什么这里必须用 `sort`**，全部用**纯白话**，不写代码示例以外的内容，不出现人称代词。

---

## 一、`nums.sort()` 这一句在干什么（最直观版本）

这一句的意思只有一句话：

> **把 `nums` 这个列表里的所有数字，直接按从小到大的顺序排好。**

关键词只有三个：

* `nums`：一个**列表**
* `.`：表示“对它做事”
* `sort()`：排序这件事

执行完这句之后：

* `nums` 本身已经变成**排好序的状态**
* 原来的顺序**彻底被改变**
* 不会生成新的列表

---

## 二、为什么要先排序（和三数之和直接相关）

排序不是为了好看，而是为了**能用“左右夹逼”的办法**：

* 小的数在左边
* 大的数在右边
* 和太小 → 往右找
* 和太大 → 往左找

**如果不排序，这些判断全部失效**，后面的算法根本无法成立。

---

## 三、`sort` 和 `sorted` 的本质区别（一句话总览）

| 对比点     | `sort()` | `sorted()`  |
| ------- | -------- | ----------- |
| 属于谁     | 列表的方法    | Python 内建函数 |
| 是否改变原对象 | ✅ 改变     | ❌ 不改变       |
| 是否有返回值  | ❌ 没有     | ✅ 返回新列表     |
| 适用对象    | 只能是 list | 所有可迭代对象     |

---

## 四、`sort()` 的详细解释（拆到最小）

### 1️⃣ `sort` 是谁的东西？

* `sort` **不是函数**
* `sort` 是 **列表（list）专属的方法**

只有下面这种东西才能用：

* `[1, 3, 2]`
* 也就是：**列表**

不能用于：

* 字符串
* 元组
* 集合
* 生成器

---

### 2️⃣ `sort()` 做了什么事？

`sort()` 做的是：

> **直接在原来的列表上动手，把顺序改掉**

关键点：

* 没有新列表产生
* 原列表被“就地修改”
* 排序完成后，原来的顺序消失

---

### 3️⃣ `sort()` 为什么没有返回值？

原因非常重要：

* 因为排序结果**已经体现在原列表里**
* 再返回一个东西是多余的

所以：

* `sort()` 的返回值是 `None`
* 排序效果通过 **原列表本身** 体现

---

## 五、`sorted()` 的详细解释（对照理解）

### 1️⃣ `sorted` 是什么？

* `sorted` 是 **Python 自带的函数**
* 不属于任何对象

调用形式是：

> 把一个东西交给 `sorted`，它负责排序

---

### 2️⃣ `sorted()` 能处理什么？

`sorted()` 能处理：

* 列表
* 字符串
* 元组
* 集合
* 任何“能一个一个拿出来的东西”

这类东西统称为：**可迭代对象**

---

### 3️⃣ `sorted()` 的核心特征

`sorted()` 的行为是：

* **不碰原来的对象**
* 新建一个排好序的列表
* 原对象保持原样

---

## 六、为什么这里必须用 `nums.sort()`，而不是 `sorted(nums)`

原因只有一个，但非常关键：

> **后续代码要反复使用已经排序好的 `nums` 本身**

算法逻辑是：

* 固定一个位置 `i`
* 使用 `nums[left]`、`nums[right]`
* 全程都依赖 `nums` 的顺序关系

如果使用 `sorted(nums)`：

* 排好序的结果会变成“新列表”
* 原来的 `nums` 仍然是乱序
* 后续指针逻辑全部失效

因此：

> **这里必须让 `nums` 自身变成有序**

---

## 七、关于题目中提到的 `join()`（顺带澄清）

### 1️⃣ `join()` 是干什么的？

`join()` 的用途是：

> **把一堆字符串，用指定的分隔符连成一个大字符串**

例如：

* `" "`：空格
* `","`：逗号
* `"->"`：箭头

---

### 2️⃣ `join()` 和排序有没有关系？

**完全没有关系。**

* `join()`：字符串拼接
* `sort / sorted`：顺序排列

`join()`：

* 不能排序
* 不能处理数字
* 只能用于字符串序列

在“三数之和”这道题中：

> **`join()` 完全不参与任何逻辑**

---

## 八、一句话总结（必须记住）

* `nums.sort()`：
  👉 **直接把原列表排好序，不返回新东西**

* `sorted(nums)`：
  👉 **返回一个新的排好序的列表，原列表不变**

* 本题必须使用 `nums.sort()`：
  👉 **因为后续算法依赖排序后的原数组**

---


