# leetcode15. 三数之和

---

## （0）【纯人话，不写代码】解题思路（零基础版）

这道题的目标只有一句话：

> **从一堆整数里，找出所有三个数，它们加起来等于 0，而且不能重复。**

### 一、为什么不能用“瞎试”

假设数组里有 1000 个数。
如果随便选 3 个数来试：

* 第一个数有 1000 种选法
* 第二个数有 999 种
* 第三个数有 998 种

组合数量会非常非常多，计算机会“累死”。

所以需要**聪明的方法**。

---

### 二、关键思想：**排序 + 两头夹**

#### 第一步：排序

先把数组按从小到大排好，例如：

```
[-4, -1, -1, 0, 1, 2]
```

排序的好处：

* 小的在左边
* 大的在右边
* 数字有规律，方便“试探大小”

---

#### 第二步：固定一个数，再找另外两个数

思路是：

1. **先固定一个数**（当作“老大”）
2. 剩下的问题就变成：

> 在后面的数里，找两个数，让
> `这两个数 + 老大 = 0`

也就是：

```
这两个数的和 = -老大
```

---

#### 第三步：左右指针夹逼

在排好序的数组中：

* 左指针从小的一侧开始
* 右指针从大的一侧开始

然后：

* 如果三数之和 **太小** → 左指针往右走（变大）
* 如果三数之和 **太大** → 右指针往左走（变小）
* 如果刚好等于 0 → 记录答案，然后左右一起移动

---

#### 第四步：去重（非常重要）

题目明确说：

> **不能有重复的三元组**

所以：

* 固定的数如果和上一次一样，直接跳过
* 找到答案后，左右指针如果指向的数和刚才一样，也要跳过

---

### 五个字总结思路

> **排序 + 固定 + 夹逼 + 去重**

---

## （1）Python3 标准答案（每一行都有中文注释）

```python
class Solution:
    def threeSum(self, nums):
        nums.sort()                         # 把数组从小到大排序
        res = []                            # 用来存放最终结果的列表

        n = len(nums)                       # 数组长度

        for i in range(n):                  # 固定第一个数的下标 i
            if i > 0 and nums[i] == nums[i - 1]:
                continue                    # 如果和前一个数一样，跳过，防止重复

            left = i + 1                    # 左指针，指向 i 右边的第一个数
            right = n - 1                   # 右指针，指向数组最后一个数

            while left < right:             # 左右指针没有相遇时循环
                total = nums[i] + nums[left] + nums[right]  # 三个数的和

                if total == 0:
                    res.append([nums[i], nums[left], nums[right]])  # 找到一个答案

                    left += 1               # 左指针右移
                    right -= 1              # 右指针左移

                    while left < right and nums[left] == nums[left - 1]:
                        left += 1           # 跳过重复的左边数字

                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1          # 跳过重复的右边数字

                elif total < 0:
                    left += 1               # 和太小，左指针右移

                else:
                    right -= 1              # 和太大，右指针左移

        return res                           # 返回所有不重复的三元组
```

---

## （2）【一个字母一个字母、一句一句】解释代码（极端零基础）

下面从**最基本**开始解释。

---

### `class Solution:`

* `class`：定义一个“盒子”
* `Solution`：盒子的名字
* 这个盒子里专门放解题方法

---

### `def threeSum(self, nums):`

* `def`：定义一个功能
* `threeSum`：功能名字
* `nums`：传进来的数字列表，例如 `[-1,0,1]`

---

### `nums.sort()`

* `nums`：原始数字列表
* `.`：表示“对它做事情”
* `sort()`：排序
* 作用：把数字按从小到大排列

---

### `res = []`

* `=`：把右边的东西放进左边
* `[]`：空盒子（列表）
* `res`：用来装答案的盒子

---

### `n = len(nums)`

* `len`：长度
* `len(nums)`：nums 里有多少个数字
* `n`：记住这个数量

---

### `for i in range(n):`

* `for`：重复做事情
* `i`：下标，从 0 开始
* `range(n)`：0 到 n-1

---

### `if i > 0 and nums[i] == nums[i - 1]:`

* `i > 0`：不是第一个数
* `nums[i] == nums[i - 1]`：当前数字和前一个一样
* 意思：**这个数已经用过了**

---

### `continue`

* 跳过本次循环
* 直接去下一个 `i`

---

### `left = i + 1`

* 左指针
* 指向固定数字右边的第一个位置

---

### `right = n - 1`

* 右指针
* 指向数组最右边

---

### `while left < right:`

* 只要左边还在右边左侧
* 就继续找

---

### `total = nums[i] + nums[left] + nums[right]`

* 把三个数加起来
* 存到 `total`

---

### `if total == 0:`

* 如果刚好等于 0
* 找到一个答案

---

### `res.append([...])`

* `append`：把东西放进盒子
* 把三个数字一起放进去

---

### `left += 1` / `right -= 1`

* 左指针右移
* 右指针左移

---

### 跳过重复数字的 `while`

* 如果新指向的数字和刚才一样
* 继续移动
* 防止结果重复

---

### `elif total < 0`

* 和太小
* 需要更大的数
* 左指针右移

---

### `else`

* 和太大
* 需要更小的数
* 右指针左移

---

### `return res`

* 把结果交出去
* 算法结束

---

## （3）具体数值算例 + 过程表格

### 示例输入

```
nums = [-1, 0, 1, 2, -1, -4]
```

### 排序后

```
[-4, -1, -1, 0, 1, 2]
```

---

### 关键过程表（只列核心步骤）

| i位置 | 固定值 | left  | right | 三数之和 | 动作 |
| --- | --- | ----- | ----- | ---- | -- |
| 0   | -4  | 1(-1) | 5(2)  | -3   | 左移 |
| 0   | -4  | 2(-1) | 5(2)  | -3   | 左移 |
| 0   | -4  | 3(0)  | 5(2)  | -2   | 左移 |
| 0   | -4  | 4(1)  | 5(2)  | -1   | 左移 |
| 1   | -1  | 2(-1) | 5(2)  | 0    | 记录 |
| 1   | -1  | 3(0)  | 4(1)  | 0    | 记录 |

---

### 最终结果

```
[[-1, -1, 2], [-1, 0, 1]]
```

---

## （4）公式与关键表达式来源说明

### ① `三数之和 = nums[i] + nums[left] + nums[right]`

来源：
题目要求三个数加起来等于 0。

---

### ② `left < right`

来源：
三个数必须是**不同位置**，左右指针相遇就不能再组成三个数。

---

### ③ `nums[i] == nums[i - 1]`

来源：
排序后，相同的数会挨在一起。
如果继续使用，会产生**重复答案**。

